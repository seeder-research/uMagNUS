#define ELEMENTS_PER_BLOCK 256
#define SKEIN_KS_PARITY 0x1BD11BDAA9FC1A22

/**
State of threefry RNG.
*/
typedef struct{
	uint2 counter;
	uint2 result;
	uint2 key;
	uint tracker;
} threefry_state;


inline static ulong rotL(ulong x, uint N){
  return ((x << N) | (x >> (64 - N)));
}

static inline void threefry_round(threefry_state* state){
    uint ks[3];
    ks[2] = SKEIN_KS_PARITY;
    ks[0] = state.key.x;
    state.result.x  = state.counter.x;
    ks[2] ^= state.key.x;
    ks[1] = state.key.y;
    state.result.y  = state.counter.y;
    ks[2] ^= state.key.y;
    state.result.x += ks[0];
    state.result.y += ks[1];
    state.result.x += state.result.y;
    state.result.y = rotL(state.result.y, R0);
    state.result.y ^= state.result.x;
    state.result.x += state.result.y;
    state.result.y = rotL(state.result.y, R1);
    state.result.y ^= state.result.x;
    state.result.x += state.result.y;
    state.result.y = rotL(state.result.y, R2);
    state.result.y ^= state.result.x;
    state.result.x += state.result.y;
    state.result.y = rotL(state.result.y, R3);
    state.result.y ^= state.result.x;
    /* InjectKey(r=1) */
    state.result.x += ks[1];
    state.result.y += ks[2];
    state.result.y += 1; /* X[2-1] += r  */
    state.result.x += state.result.y;
    state.result.y = rotL(state.result.y, R4);
    state.result.y ^= state.result.x;
    state.result.x += state.result.y;
    state.result.y = rotL(state.result.y, R5);
    state.result.y ^= state.result.x;
    state.result.x += state.result.y;
    state.result.y = rotL(state.result.y, R6);
    state.result.y ^= state.result.x;
    state.result.x += state.result.y;
    state.result.y = rotL(state.result.y, R7);
    state.result.y ^= state.result.x;
    /* InjectKey(r=2) */
    state.result.x += ks[2];
    state.result.y += ks[0];
    state.result.y += 2;
    state.result.x += state.result.y;
    state.result.y = rotL(state.result.y, R0);
    state.result.y ^= state.result.x;
    state.result.x += state.result.y;
    state.result.y = rotL(state.result.y, R1);
    state.result.y ^= state.result.x;
    state.result.x += state.result.y;
    state.result.y = rotL(state.result.y, R2);
    state.result.y ^= state.result.x;
    state.result.x += state.result.y;
    state.result.y = rotL(state.result.y, R3);
    state.result.y ^= state.result.x;
    /* InjectKey(r=3) */
    state.result.x += ks[0];
    state.result.y += ks[1];
    state.result.y += 3;
    state.result.x += state.result.y;
    state.result.y = rotL(state.result.y, R4);
    state.result.y ^= state.result.x;
    state.result.x += state.result.y;
    state.result.y = rotL(state.result.y, R5);
    state.result.y ^= state.result.x;
    state.result.x += state.result.y;
    state.result.y = rotL(state.result.y, R6);
    state.result.y ^= state.result.x;
    state.result.x += state.result.y;
    state.result.y = rotL(state.result.y, R7);
    state.result.y ^= state.result.x;
    /* InjectKey(r=4) */
    state.result.x += ks[1];
    state.result.y += ks[2];
    state.result.y += 4;
}

/******************************
*/

/// \brief Threefry4x32 counter type
/// \ingroup ThreefryC
typedef struct {
    uint32_t v[4];
} mckl_threefry4x32_ctr_t;

/// \brief Threefry4x32 key type
/// \ingroup ThreefryC
typedef struct {
    uint32_t v[4];
} mckl_threefry4x32_key_t;

typedef struct {
    uint32_t v[5];
} mckl_threefry4x32_par_t;

/// \brief Threefry4x32 RNG state structure
/// \ingroup ThreefryC
typedef struct {
    mckl_threefry4x32_ctr_t state;
    mckl_threefry4x32_ctr_t ctr;
    mckl_threefry4x32_key_t key;
    uint32_t index;
} mckl_threefry4x32;

static inline void mckl_threefry4x32_inc(mckl_threefry4x32_ctr_t *ctr)
{
    if (++ctr->v[0] != 0) {
        return;
    }
    if (++ctr->v[1] != 0) {
        return;
    }
    if (++ctr->v[2] != 0) {
        return;
    }
    if (++ctr->v[3] != 0) {
        return;
    }
}

static inline void mckl_threefry4x32_initpar(
    const mckl_threefry4x32_key_t *key, mckl_threefry4x32_par_t *par)
{
    par->v[0] = key->v[0];
    par->v[1] = key->v[1];
    par->v[2] = key->v[2];
    par->v[3] = key->v[3];

    par->v[4] = UINT32_C(0x1BD11BDA);
    par->v[4] ^= par->v[0];
    par->v[4] ^= par->v[1];
    par->v[4] ^= par->v[2];
    par->v[4] ^= par->v[3];
}

static inline void mckl_threefry4x32_rotate(
    mckl_threefry4x32_ctr_t *state, uint32_t r0, uint32_t r2, int i0, int i2)
{
    state->v[0] += state->v[i0];
    state->v[i0] = ((state->v[i0]) << r0) | ((state->v[i0]) >> (32 - r0));
    state->v[i0] ^= state->v[0];

    state->v[2] += state->v[i2];
    state->v[i2] = ((state->v[i2]) << r2) | ((state->v[i2]) >> (32 - r2));
    state->v[i2] ^= state->v[2];
}

static inline void mckl_threefry4x32_insertkey(mckl_threefry4x32_ctr_t *state,
    const mckl_threefry4x32_par_t *par, uint32_t inc, int i0, int i1, int i2,
    int i3)
{
    state->v[0] += par->v[i0];
    state->v[1] += par->v[i1];
    state->v[2] += par->v[i2];
    state->v[3] += par->v[i3];
    state->v[3] += inc;
}

static inline void mckl_threefry4x32_gen(const mckl_threefry4x32_ctr_t *ctr,
    const mckl_threefry4x32_key_t *key, mckl_threefry4x32_ctr_t *state)
{
    *state = *ctr;
    mckl_threefry4x32_par_t par;
    mckl_threefry4x32_initpar(key, &par);

    mckl_threefry4x32_insertkey(state, &par, 0, 0, 1, 2, 3);
    mckl_threefry4x32_rotate(state, 10, 26, 1, 3);
    mckl_threefry4x32_rotate(state, 11, 21, 3, 1);
    mckl_threefry4x32_rotate(state, 13, 27, 1, 3);
    mckl_threefry4x32_rotate(state, 23, 5, 3, 1);
    mckl_threefry4x32_insertkey(state, &par, 1, 1, 2, 3, 4);
    mckl_threefry4x32_rotate(state, 6, 20, 1, 3);
    mckl_threefry4x32_rotate(state, 17, 11, 3, 1);
    mckl_threefry4x32_rotate(state, 25, 10, 1, 3);
    mckl_threefry4x32_rotate(state, 18, 20, 3, 1);
    mckl_threefry4x32_insertkey(state, &par, 2, 2, 3, 4, 0);
    mckl_threefry4x32_rotate(state, 10, 26, 1, 3);
    mckl_threefry4x32_rotate(state, 11, 21, 3, 1);
    mckl_threefry4x32_rotate(state, 13, 27, 1, 3);
    mckl_threefry4x32_rotate(state, 23, 5, 3, 1);
    mckl_threefry4x32_insertkey(state, &par, 3, 3, 4, 0, 1);
    mckl_threefry4x32_rotate(state, 6, 20, 1, 3);
    mckl_threefry4x32_rotate(state, 17, 11, 3, 1);
    mckl_threefry4x32_rotate(state, 25, 10, 1, 3);
    mckl_threefry4x32_rotate(state, 18, 20, 3, 1);
    mckl_threefry4x32_insertkey(state, &par, 4, 4, 0, 1, 2);
    mckl_threefry4x32_rotate(state, 10, 26, 1, 3);
    mckl_threefry4x32_rotate(state, 11, 21, 3, 1);
    mckl_threefry4x32_rotate(state, 13, 27, 1, 3);
    mckl_threefry4x32_rotate(state, 23, 5, 3, 1);
    mckl_threefry4x32_insertkey(state, &par, 5, 0, 1, 2, 3);
}

static inline void mckl_threefry4x32_init(
    mckl_threefry4x32 *rng, uint32_t seed)
{
    rng->ctr.v[0] = 0;
    rng->ctr.v[1] = 0;
    rng->ctr.v[2] = 0;
    rng->ctr.v[3] = 0;
    rng->key.v[0] = seed;
    rng->key.v[1] = 0;
    rng->key.v[2] = 0;
    rng->key.v[3] = 0;
    rng->index = 4;
}

static inline uint32_t mckl_threefry4x32_rand(mckl_threefry4x32 *rng)
{
    if (rng->index == 4) {
        mckl_threefry4x32_inc(&rng->ctr);
        mckl_threefry4x32_gen(&rng->ctr, &rng->key, &rng->state);
        rng->index = 0;
    }

    return rng->state.v[rng->index++];
}

