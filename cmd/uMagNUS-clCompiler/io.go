package main

import (
	"bufio"
	e "encoding/hex"
	"fmt"
	"log"
	"os"
)

func readFile(fname string) string {
	if *Flag_verbose > 5 {
		fmt.Println("Attempting to open file: ", fname)
	}
	f, err := os.Open(fname)
	if err != nil {
		log.Fatalf("Unable to open file: %v \n", fname)
		return ""
	}
	defer f.Close()

	in := bufio.NewReader(f)
	var nline string
	line, eof := readLine(in)
	for !eof {
		line = line + nline + "\n"
		nline, eof = readLine(in)
	}
	if nline != "" {
		line += nline
	}
	return line
}

func printHeader() string {
	outcode := string("////////////////////////////////////////////////////////////////////////\n")
	outcode += "// DO NOT EDIT THIS FILE!\n"
	outcode += "// THIS FILE WAS GENERATED BY UMAGNUS-CLCOMPILER AND MAY BE OVERWRITTEN!\n//\n"
	outcode += "// This file contains code that needs to be compiled by a C compiler\n"
	outcode += "// into a library for loading uMagNUS GPU binaries\n"
	outcode += "////////////////////////////////////////////////////////////////////////\n\n"
	outcode += "#include <stdlib.h>\n\n"
	outcode += "#define HEXEXP(...) __VA_ARGS__\n\n"
	return outcode
}

func printHex(b []byte) string {
	byteLen := len(b)
	// Every byte needs 2 hex characters. Hence, 50 bytes will have 100 hex characters.
	// We will separate the hex string into lines that are at most 100 hex characters.
	hexString := string("HEXEXP(")
	for idx := 0; idx < byteLen; idx += 50 {
		var tmpByte []byte
		if byteLen <= (idx + 50) {
			tmpByte = b[idx:]
		} else {
			tmpByte = b[idx : idx+50]
		}
		hexString += "\n\t\"" + e.EncodeToString(tmpByte) + "\""
	}
	hexString += ");\n"
	return hexString
}
